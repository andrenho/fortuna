ENTER     = 13
BACKSPACE = 8

;---------------------------------------
; Print prompt ([sd]/> )
;---------------------------------------

shell_print_prompt:

        ld      hl, .prompt1
        SYS     _PRINT
        ld      hl, current_dir_str
        SYS     _PRINT
        ld      hl, .prompt2
        SYS     _PRINT
        ret
.prompt1:
        asciiz  "[SD0]"
.prompt2:
        asciiz  "> "

;---------------------------------------
; Install shell interrupt handler on interrupt vector
;---------------------------------------

shell_install_interrupt_handler:

        ld      hl, shell_interrupt_handler
        ld      (INTERRUPT_VECTOR + 0), hl
        ei
        ret

;---------------------------------------
; Execute shell command
;---------------------------------------

shell_execute:

        call    .line_is_empty                  ; check if line is empty
        cp      0
        jr      nz, .continue1
        ret
.continue1:

        call    .create_command_line            ; find file
        ld      hl, shell_cmd_line
        call    fat16_open_file_cur_dir
        cp      0
        jr      z, .continue2
        
        ld      hl, .not_found
        SYS     _PRINT
        ret
.continue2:

        ; TODO - check max file size

        ld      a, b
        ld      de, APPLICATION_AREA            ; load and execute file
        call    fat16_load_full_file
        call    process_execute
        ret                                     ; END OF PROCEDURE

        ; check if line is empty

.line_is_empty:
        ; TODO
        ret

        ; create command line (use `shell_cmd_line`)

.create_command_line:
        ; TODO
        ret

.not_found:
        asciiz  "Command not found.", 13

;---------------------------------------
; Read a line from the user
;---------------------------------------

shell_read_line:

        ; clear line

        ld      a, 0
        ld      hl, shell_cmd_line
        ld      b, 255
.next_byte:
        ld      (hl), a
        inc     hl
        djnz    .next_byte

        ; prepare

        call    shell_install_interrupt_handler ; install interrupt handler

        ; read from keyboard

        ld      hl, shell_cmd_line              ; HL = current cursor
        ld      b, 0                            ; B = number of characters
.next_key:
        halt                                    ; wait for keypress

        ; ENTER was pressed?

        ld      a, (shell_last_keypress)        ; exit if ENTER
        cp      ENTER
        jr      z, .enter_pressed

        ; BACKSPACE was pressed?

        cp      BACKSPACE                       ; BACKSPACE was pressed
        jr      nz, .skip_backspace
        ld      a, b                            ; if #cmdline == 0, skip
        cp      0
        jr      z, .next_key
        dec     hl                              ; rollback one key
        dec     b
        ld      a, BACKSPACE
        out     (I_TERMINAL), a
        jr      .next_key                       ; continue
.skip_backspace

        ; is the string too large?

        ld      a, b
        cp      255
        jr      z, .next_key

        ; print char

        ld      a, (shell_last_keypress)        ; print key
        out     (I_TERMINAL), a

        ld      (hl), a                         ; increment cursor
        inc     hl
        inc     b

        jr      .next_key

.enter_pressed:
        ld      a, ENTER
        out     (I_TERMINAL), a
        ret

;---------------------------------------
; Keyboard interrupt handler for the shell
;---------------------------------------

shell_interrupt_handler:

        di
        in      a, (I_TERMINAL)
        ld      (shell_last_keypress), a
        ei
        reti

;---------------------------------------
; VARIABLES
;---------------------------------------

shell_last_keypress:    db      0
shell_cmd_line:         fill    255

; vim: ts=8:sts=8:sw=8:expandtab
